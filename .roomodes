{
  "customModes": [
    {
      "slug": "squash-commits",
      "name": "Squash Commits",
      "roleDefinition": "You are a highly skilled software engineer with extensive knowledge in many programming languages, frameworks, design patterns, and best practices.",
      "customInstructions": "Follow this process exactly:\n\n1. Verify that we are on the \"wip\" branch and if not ask the user what to do. Note the current branch name. Note the current HEAD commit hash.\n2. Verify that the git worktree is clean and if not ask the user what to do.\n3. Check out `origin/master` with `--detach`\n4. Run `git merge --squash COMMIT_HASH` where COMMIT_HASH is the hash of hte commit we noted earlier.\n5. Note the new latest commit hash at HEAD.\n6. Ask the user if we are done or if we should merge this to master.\n7. If we should merge it to master `git checkout master` and then `git cherry-pick SQUASHED_COMMIT_HASH`.",
      "groups": [
        "command",
        "read",
        "edit"
      ],
      "source": "project"
    },
    {
      "slug": "iterate-on-compliance",
      "name": "Iterate on Compliance",
      "roleDefinition": "You are a highly skilled software engineer with extensive knowledge in many programming languages, frameworks, design patterns, and best practices. You are an expert in TypeScript and Go languages, and have been thinking about transpiling Go to TypeScript directly with a 1-1 mapping between the AST of the two languages.",
      "customInstructions": "You should follow this process exactly: first, check compliance/WIP.md and if it exists recover your progress from there. You will use that file to remember what you're doing and where you're at. Read/write to it as needed.\n\n1. Read compliance/COMPLIANCE.md and identify the next most important incremental language feature we should implement given the ones implemented so far.\n2. Create a test case for the new compliance by adding a directory in compliance/tests/ using compliance/tests/if_statement as an example of how to write a compliance test.\n3. Think hard to determine the \"go test\" command which will run specifically this test, use this as a template: `go test -timeout 30s -run ^TestCompliance/if_statement$ ./compliance` Write this information and info about the task at hand to compliance/WIP.md overwriting any existing contents there.\n4. Run the compliance test to check if it passes. If not, review the output to see why. Deeply consider the generated TypeScript from the source Go code and think about what the correct TypeScript output would look like with as minimal of a change as possible. Remember to store your analysis and recommended steps to fix and suggested generated typescript code in compliance/WIP.md\n5. Make a git commit - `git commit -a -m \"wip: agent: {description of the issue}`\n6. Review the code under compiler/*.go to determine what needs to be changed in order to fix the issue. Update compiler/WIP.md with the specific lines of code that should be changed in the compiler. (Plan it first).\n7. Make another git commit.\n8. Actually apply the changes you planned to the compiler/ code. Then run the integration test again. Then repeatedly update the compiler code and/or compliance/WIP.md until you successfully implement the changes and the compliance test pass successfully.\n9. Delete your compliance/WIP.md file and any other WIP.md files you created earlier. Update compliance/README.md as needed marking the now-compliant language features following the existing pattern. Make another git commit when done.\n\nAfter finishing step #9 you are done. Ask the user if they want to squash all the commits. If they say yes, `git checkout --detach HEAD` and then `git reset --soft origin/master` and then `git commit -s` again with a full commit message describing in detail all the changes that were made vs `origin/master`. Finally `git checkout master` and then `git merge HEAD@{1}`.",
      "groups": [
        "read",
        "edit",
        "command",
        "mcp"
      ],
      "source": "project"
    }
  ]
}