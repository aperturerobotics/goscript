import * as $ from "@goscript/builtin/builtin.js";

export type FuncFlag = number;

// FuncFlagTopFrame indicates a function that appears at the top of its stack.
// The traceback routine stop at such a function and consider that a
// successful, complete traversal of the stack.
// Examples of TopFrame functions include goexit, which appears
// at the top of a user goroutine stack, and mstart, which appears
// at the top of a system goroutine stack.
export let FuncFlagTopFrame: FuncFlag = (1 << 0)

// FuncFlagSPWrite indicates a function that writes an arbitrary value to SP
// (any write other than adding or subtracting a constant amount).
// The traceback routines cannot encode such changes into the
// pcsp tables, so the function traceback cannot safely unwind past
// SPWrite functions. Stopping at an SPWrite function is considered
// to be an incomplete unwinding of the stack. In certain contexts
// (in particular garbage collector stack scans) that is a fatal error.
export let FuncFlagSPWrite: FuncFlag = 0

// FuncFlagAsm indicates that a function was implemented in assembly.
export let FuncFlagAsm: FuncFlag = 0

export type FuncID = number;

// not a special function
export let FuncIDNormal: FuncID = 0

export let FuncID_abort: FuncID = 0

export let FuncID_asmcgocall: FuncID = 0

export let FuncID_asyncPreempt: FuncID = 0

export let FuncID_cgocallback: FuncID = 0

export let FuncID_corostart: FuncID = 0

export let FuncID_debugCallV2: FuncID = 0

export let FuncID_gcBgMarkWorker: FuncID = 0

export let FuncID_goexit: FuncID = 0

export let FuncID_gogo: FuncID = 0

export let FuncID_gopanic: FuncID = 0

export let FuncID_handleAsyncEvent: FuncID = 0

export let FuncID_mcall: FuncID = 0

export let FuncID_morestack: FuncID = 0

export let FuncID_mstart: FuncID = 0

export let FuncID_panicwrap: FuncID = 0

export let FuncID_rt0_go: FuncID = 0

export let FuncID_runfinq: FuncID = 0

export let FuncID_runtime_main: FuncID = 0

export let FuncID_sigpanic: FuncID = 0

export let FuncID_systemstack: FuncID = 0

export let FuncID_systemstack_switch: FuncID = 0

// any autogenerated code (hash/eq algorithms, method wrappers, etc.)
export let FuncIDWrapper: FuncID = 0

export let ArgsSizeUnknown: number = -0x80000000

export let PCDATA_UnsafePoint: number = 0

export let PCDATA_StackMapIndex: number = 1

export let PCDATA_InlTreeIndex: number = 2

export let PCDATA_ArgLiveIndex: number = 3

export let FUNCDATA_ArgsPointerMaps: number = 0

export let FUNCDATA_LocalsPointerMaps: number = 1

export let FUNCDATA_StackObjects: number = 2

export let FUNCDATA_InlTree: number = 3

export let FUNCDATA_OpenCodedDeferInfo: number = 4

export let FUNCDATA_ArgInfo: number = 5

export let FUNCDATA_ArgLiveInfo: number = 6

export let FUNCDATA_WrapInfo: number = 7

// Safe for async preemption
export let UnsafePointSafe: number = -1

// Unsafe for async preemption
export let UnsafePointUnsafe: number = -2

// UnsafePointRestart1(2) apply on a sequence of instructions, within
// which if an async preemption happens, we should back off the PC
// to the start of the sequence when resuming.
// We need two so we can distinguish the start/end of the sequence
// in case that two sequences are next to each other.
export let UnsafePointRestart1: number = -3

export let UnsafePointRestart2: number = -4

// Like UnsafePointRestart1, but back to function entry if async preempted.
export let UnsafePointRestartAtEntry: number = -5

// minimum size for a function
export let MINFUNC: number = 16

// size of bucket in the pc->func lookup table
export let FuncTabBucketSize: number = 256 * 16

